{
  "agent": {
    "id": "inbox_management",
    "name": "Inbox Management",
    "version": "1.0.0",
    "description": "Automatically triage unread Gmail emails using user-defined free-text rules. Fetch unread emails (configurable batch size, default 100), classify each by urgency and type, then take appropriate actions \u2014 trash spam, archive low-priority messages, mark important emails, and categorize the rest as Action Needed, FYI, or Waiting On."
  },
  "graph": {
    "id": "inbox_management-graph",
    "goal_id": "inbox-management",
    "version": "1.0.0",
    "entry_node": "intake",
    "entry_points": {
      "start": "intake"
    },
    "pause_nodes": [],
    "terminal_nodes": [
      "report"
    ],
    "nodes": [
      {
        "id": "intake",
        "name": "Intake",
        "description": "Receive and validate input parameters: rules and max_emails. Present the interpreted rules back to the user for confirmation before proceeding.",
        "node_type": "event_loop",
        "input_keys": [
          "rules",
          "max_emails"
        ],
        "output_keys": [
          "rules",
          "max_emails"
        ],
        "nullable_output_keys": [],
        "input_schema": {},
        "output_schema": {},
        "system_prompt": "You are an inbox management assistant. The user has provided triage rules for managing their unread emails.\n\n**STEP 1 \u2014 Respond to the user (text only, NO tool calls):**\n\nRead the user's triage rules from the input context. Present a clear summary of how you will categorize and act on their emails:\n\n- What will be TRASHED (spam, unwanted)\n- What will be ARCHIVED (low-priority, newsletters)\n- What will be marked IMPORTANT (urgent, action-needed)\n- How emails will be CATEGORIZED (Action Needed, FYI, Waiting On)\n\nAlso confirm the batch size (max_emails). If max_emails is not provided, default to 100.\n\nAsk the user to confirm: \"Does this look right? I'll proceed once you confirm.\"\n\n**STEP 2 \u2014 After the user confirms, call set_output:**\n\n- set_output(\"triage_rules\", <the confirmed triage rules as a clear text description>)\n- set_output(\"max_emails\", <the confirmed max_emails as a string number, e.g. \"100\">)",
        "tools": [],
        "model": null,
        "function": null,
        "routes": {},
        "max_retries": 3,
        "retry_on": [],
        "max_node_visits": 1,
        "output_model": null,
        "max_validation_retries": 2,
        "client_facing": true
      },
      {
        "id": "fetch-emails",
        "name": "Fetch Emails",
        "description": "Fetch emails from the Gmail inbox up to the configured batch limit. Processes emails in small batches across multiple iterations to stay within tool call limits. Saves results to a file.",
        "node_type": "event_loop",
        "input_keys": [
          "rules",
          "max_emails"
        ],
        "output_keys": [
          "emails"
        ],
        "nullable_output_keys": [],
        "input_schema": {},
        "output_schema": {},
        "system_prompt": "You are an inbox management assistant. Your job is to fetch emails from the Gmail inbox.\n\n**CRITICAL \u2014 WORK IN SMALL BATCHES:**\nYou MUST limit yourself to at most 25 tool calls per iteration. This means:\n- First iteration: call gmail_list_messages ONCE, then call gmail_get_message for UP TO 24 of the returned messages. If there are more messages remaining, do NOT call set_output yet \u2014 just stop and wait for the next iteration.\n- Subsequent iterations: continue calling gmail_get_message for remaining messages from the current page (up to 25 calls per iteration). When the current page is done and you need more emails, call gmail_list_messages with the page_token to get the next page.\n- Final iteration: once you have fetched enough emails (up to max_emails) or there are no more pages, save to file and set output.\n\n**IMPORTANT CONSTRAINTS:**\n- Fetch emails from the inbox using the query \"label:INBOX\" with gmail_list_messages.\n- Fetch at most the number specified in max_emails (from context).\n- Use max_results of 50 per gmail_list_messages call (to keep pages manageable).\n\n**CRITICAL \u2014 Message IDs:**\n- gmail_list_messages returns objects with BOTH \"id\" and \"threadId\". These are DIFFERENT values.\n- You MUST use the \"id\" field (NOT \"threadId\") when calling gmail_get_message.\n- If gmail_get_message returns {\"error\": \"Message not found\"}, SKIP that message and continue.\n\n**PROCESS (repeat across iterations):**\n1. If this is your first iteration, call gmail_list_messages with query \"label:INBOX\" and max_results=50.\n2. Call gmail_get_message for up to 24 messages (using the \"id\" field, NOT \"threadId\").\n3. Keep a running count of all emails fetched so far across all iterations.\n4. If you still need more emails AND there are more messages on the current page or a next_page_token exists:\n   - Do NOT call set_output yet. Stop and wait for the next iteration to continue.\n5. Once you have fetched enough emails (reached max_emails) or exhausted all pages:\n   a. Build a JSON array of all collected emails.\n   b. Call save_data(filename=\"emails.json\", data=<the JSON array as a string>) to write the emails to a file.\n   c. Call set_output(\"emails\", \"emails.json\") \u2014 pass ONLY the filename, NOT the email data.\n\n**CRITICAL \u2014 DO NOT pass email data directly to set_output. The data is too large. Always save to file first with save_data, then pass the filename.**\n\nEach email should include: id, subject, from, date, snippet, and current labels.\n\nIf there are no emails, set_output(\"emails\", \"[]\").",
        "tools": [
          "gmail_list_messages",
          "gmail_get_message",
          "save_data"
        ],
        "model": null,
        "function": null,
        "routes": {},
        "max_retries": 3,
        "retry_on": [],
        "max_node_visits": 1,
        "output_model": null,
        "max_validation_retries": 2,
        "client_facing": false
      },
      {
        "id": "classify-and-act",
        "name": "Classify and Act",
        "description": "Execute the user's rules on each email using the appropriate Gmail actions, with batch operations where possible. Loads emails from a file saved by the fetch-emails node.",
        "node_type": "event_loop",
        "input_keys": [
          "rules",
          "emails"
        ],
        "output_keys": [
          "actions_taken"
        ],
        "nullable_output_keys": [],
        "input_schema": {},
        "output_schema": {},
        "system_prompt": "You are an inbox management assistant. Your job is to execute the user's rules on their emails.\n\n**STEP 1 \u2014 LOAD EMAILS FROM FILE:**\nThe \"emails\" key in context contains a FILENAME (e.g. \"emails.json\"), NOT the actual email data.\nYou MUST call load_data(filename=<the filename from context>) to retrieve the email list.\nUse pagination (offset/limit) if the file is large \u2014 load_data returns 50 lines at a time by default.\n\n**RULES** are provided in the context as \"rules\". Read them carefully \u2014 they tell you exactly what to do.\n\nIf the rules say to apply ONE action to ALL emails (e.g. \"mark all as unread\"), just do that. Do NOT classify or categorize emails unless the rules specifically ask for it.\n\n**AVAILABLE ACTIONS (use ONLY these Gmail system labels):**\n1. **TRASH** \u2014 Use gmail_trash_message(message_id) individually.\n2. **SPAM** \u2014 Use gmail_batch_modify_messages(message_ids=[...], add_labels=[\"SPAM\"], remove_labels=[\"INBOX\"]).\n3. **MARK IMPORTANT** \u2014 Use gmail_batch_modify_messages(message_ids=[...], add_labels=[\"IMPORTANT\"]).\n4. **MARK AS UNREAD** \u2014 Use gmail_batch_modify_messages(message_ids=[...], add_labels=[\"UNREAD\"]).\n5. **MARK AS READ** \u2014 Use gmail_batch_modify_messages(message_ids=[...], remove_labels=[\"UNREAD\"]).\n6. **ARCHIVE** \u2014 Use gmail_batch_modify_messages(message_ids=[...], remove_labels=[\"INBOX\"]).\n7. **STAR** \u2014 Use gmail_batch_modify_messages(message_ids=[...], add_labels=[\"STARRED\"]).\n\n**CRITICAL \u2014 VALID GMAIL LABELS ONLY:**\nYou can ONLY use these system label IDs: INBOX, UNREAD, IMPORTANT, STARRED, SPAM, TRASH, SENT, DRAFT, CATEGORY_PERSONAL, CATEGORY_SOCIAL, CATEGORY_PROMOTIONS, CATEGORY_UPDATES, CATEGORY_FORUMS.\nDo NOT use custom labels like \"FYI\", \"Action Needed\", or \"Waiting On\" \u2014 these will cause API errors.\n\n**IMPORTANT \u2014 USE BATCH OPERATIONS TO MINIMIZE TOOL CALLS:**\n- Group emails by action and execute in bulk using gmail_batch_modify_messages \u2014 one call per action group.\n- Only use gmail_trash_message individually for emails that need trashing.\n- Process in batches of up to 25 tool calls per iteration. If you have more actions, stop and continue in the next iteration.\n\n**PROCESS:**\n1. Load emails from the file using load_data(filename=<emails filename from context>). Page through with offset/limit if needed.\n2. Read the rules from context.\n3. For each email, determine what action the rules require.\n4. Group emails by action and execute batch operations.\n5. Track every action: {email_id, subject, from, action}.\n6. After processing ALL emails, call set_output(\"actions_taken\", <JSON string of the actions list>).\n\nIf the emails list is empty, set_output(\"actions_taken\", \"[]\").",
        "tools": [
          "gmail_trash_message",
          "gmail_modify_message",
          "gmail_batch_modify_messages",
          "load_data"
        ],
        "model": null,
        "function": null,
        "routes": {},
        "max_retries": 3,
        "retry_on": [],
        "max_node_visits": 1,
        "output_model": null,
        "max_validation_retries": 2,
        "client_facing": false
      },
      {
        "id": "report",
        "name": "Report",
        "description": "Generate a summary report of all actions taken, organized by action type.",
        "node_type": "event_loop",
        "input_keys": [
          "actions_taken"
        ],
        "output_keys": [
          "summary_report"
        ],
        "nullable_output_keys": [],
        "input_schema": {},
        "output_schema": {},
        "system_prompt": "You are an inbox management assistant. Your job is to generate a clear summary report of the triage actions taken.\n\n**READ the actions_taken list from context.** It contains objects with: email_id, subject, from, classification, action, category.\n\n**GENERATE a summary report with these sections:**\n\n1. **Overview** \u2014 Total emails processed, breakdown by action (trashed, archived, marked important, categorized only).\n\n2. **Trashed** \u2014 List of emails that were trashed, with subject and sender.\n\n3. **Archived** \u2014 List of emails that were archived, with subject and sender.\n\n4. **Marked Important** \u2014 List of emails marked important, with subject and sender.\n\n5. **By Category:**\n   - **Action Needed** \u2014 Emails requiring user action\n   - **FYI** \u2014 Informational emails\n   - **Waiting On** \u2014 Emails waiting for a response from others\n\n6. **No Action Taken** \u2014 Any emails that didn't match any rules (if applicable).\n\nFormat the report as clean, readable text (not JSON).\n\nAfter generating the report, call:\n- set_output(\"summary_report\", <the formatted report text>)",
        "tools": [],
        "model": null,
        "function": null,
        "routes": {},
        "max_retries": 3,
        "retry_on": [],
        "max_node_visits": 1,
        "output_model": null,
        "max_validation_retries": 2,
        "client_facing": false
      }
    ],
    "edges": [
      {
        "id": "intake-to-fetch-emails",
        "source": "intake",
        "target": "fetch-emails",
        "condition": "on_success",
        "condition_expr": null,
        "priority": 1,
        "input_mapping": {}
      },
      {
        "id": "fetch-emails-to-classify",
        "source": "fetch-emails",
        "target": "classify-and-act",
        "condition": "on_success",
        "condition_expr": null,
        "priority": 1,
        "input_mapping": {}
      },
      {
        "id": "classify-to-report",
        "source": "classify-and-act",
        "target": "report",
        "condition": "on_success",
        "condition_expr": null,
        "priority": 1,
        "input_mapping": {}
      }
    ],
    "max_steps": 100,
    "max_retries_per_node": 3,
    "description": "Automatically triage unread Gmail emails using user-defined free-text rules. Fetch unread emails (configurable batch size, default 100), classify each by urgency and type, then take appropriate actions \u2014 trash spam, archive low-priority messages, mark important emails, and categorize the rest as Action Needed, FYI, or Waiting On.",
    "created_at": "2026-02-11T19:09:55.831652"
  },
  "goal": {
    "id": "inbox-management",
    "name": "Inbox Management",
    "description": "Automatically triage unread Gmail emails using user-defined free-text rules. Fetch unread emails (configurable batch size, default 100), classify each by urgency and type, then take appropriate actions \u2014 trash spam, archive low-priority messages, mark important emails, and categorize the rest as Action Needed, FYI, or Waiting On.",
    "status": "draft",
    "success_criteria": [
      {
        "id": "email-classification-accuracy",
        "description": "Each unread email is classified according to the user's free-text rules with appropriate urgency category (action needed, FYI, waiting on) and type (spam, newsletter, important, etc.)",
        "metric": "classification_match_rate",
        "target": ">=90%",
        "weight": 0.3,
        "met": false
      },
      {
        "id": "correct-action-execution",
        "description": "Trash, archive, mark-important, and label actions are applied correctly to the right emails based on classification",
        "metric": "action_correctness",
        "target": ">=95%",
        "weight": 0.25,
        "met": false
      },
      {
        "id": "unread-only-guarantee",
        "description": "Only unread emails are fetched and processed; read emails are never modified",
        "metric": "read_email_modifications",
        "target": "0",
        "weight": 0.2,
        "met": false
      },
      {
        "id": "classification-report",
        "description": "Produces a summary report showing what was done: how many trashed, archived, marked important, and categorized, with email subjects listed per category",
        "metric": "report_completeness",
        "target": "100%",
        "weight": 0.15,
        "met": false
      },
      {
        "id": "batch-completeness",
        "description": "All fetched emails up to the configured max are classified and acted upon; none are silently skipped",
        "metric": "emails_processed_ratio",
        "target": "100%",
        "weight": 0.1,
        "met": false
      }
    ],
    "constraints": [
      {
        "id": "no-read-email-modification",
        "description": "Must never modify, trash, or relabel emails that are already read",
        "constraint_type": "hard",
        "category": "safety",
        "check": ""
      },
      {
        "id": "respect-batch-limit",
        "description": "Must not process more emails than the configured max_emails parameter",
        "constraint_type": "hard",
        "category": "operational",
        "check": ""
      },
      {
        "id": "non-destructive-default",
        "description": "Archiving removes from inbox but preserves the email; only explicit trash rules move emails to trash",
        "constraint_type": "hard",
        "category": "safety",
        "check": ""
      }
    ],
    "context": {},
    "required_capabilities": [],
    "input_schema": {},
    "output_schema": {},
    "version": "1.0.0",
    "parent_version": null,
    "evolution_reason": null,
    "created_at": "2026-02-11 19:07:16.319634",
    "updated_at": "2026-02-11 19:07:16.319645"
  },
  "required_tools": [
    "gmail_modify_message",
    "gmail_list_messages",
    "gmail_get_message",
    "gmail_trash_message",
    "gmail_batch_modify_messages",
    "save_data",
    "load_data"
  ],
  "metadata": {
    "created_at": "2026-02-11T19:09:55.831691",
    "node_count": 4,
    "edge_count": 3
  }
}